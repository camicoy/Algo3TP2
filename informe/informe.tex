\documentclass[a4paper]{article}
\usepackage[spanish]{babel}
\usepackage[utf8]{inputenc}
\usepackage{fancyhdr}
%\usepackage{charter}   % tipografía
\usepackage{graphicx}
\usepackage{makeidx}
\usepackage{mathptmx}

\usepackage{float}
\usepackage{amsmath, amsthm, amssymb}
\usepackage{amsfonts}
\usepackage{sectsty}
\usepackage{wrapfig}
\usepackage{listings} % necesario para el resaltado de sintaxis
\usepackage{caption}
%%%%%%%%%% Paquete para hacer grafos
%%% ver link http://www.texample.net/tikz/examples/bridges-of-konigsberg/
%\usepackage{fullpage}
%\usepackage{fourier}
\usepackage{tikz}
\usetikzlibrary{arrows,%
                shapes,positioning}
                
\thispagestyle{empty}
%%%%%%%%%% Fin paquete para hacer grafos
%%%%%%%%%%
\usepackage{hyperref} % agrega hipervínculos en cada entrada del índice
\hypersetup{          % (en el pdf)
    colorlinks=true,
    linktoc=all,
    citecolor=black,
    filecolor=black,
    linkcolor=black,
    urlcolor=black
}

\input{codesnippet}
\input{page.layout}
\usepackage{underscore}
\usepackage{caratula}
\usepackage{url}
\usepackage{color}
\usepackage{clrscode3e} % necesario para el pseudocodigo (estilo Cormen)

%\usepackage{algorithm}
%\usepackage{algorithmic}
\usepackage{algorithm}[1]
\usepackage{algorithmic}[1]
%\usepackage{algpseudocode}

\definecolor{dkgreen}{rgb}{0,0.6,0}
\definecolor{gray}{rgb}{0.5,0.5,0.5}
\definecolor{mauve}{rgb}{0.58,0,0.82}

\definecolor{gray}{gray}{0.5}
\definecolor{light-gray}{gray}{1}
\definecolor{orange}{rgb}{1,0.5,0}

\lstset{frame=tb,
  language=JAVA,
  aboveskip=3mm,
  belowskip=3mm,
  showstringspaces=false,
  columns=flexible,
  basicstyle={\small\ttfamily},
  keywordstyle=\color{blue},
  commentstyle=\color{dkgreen},
  stringstyle=\color{mauve},
  breaklines=true,
  breakatwhitespace=true,
  tabsize=3,
  numbers=left,
  xleftmargin=2em,
  frame=single,
  framexleftmargin=2em,
  numbersep=5pt,                   % how far the line-numbers are from the code
  numberstyle=\small\color{gray} % the style that is used for the line-numbers
 }
 
 \lstdefinestyle{customc}{
  backgroundcolor=\color{light-gray},
  belowcaptionskip=1\baselineskip,
  breaklines=true,
  numbers=left,
  xleftmargin=\parindent,
  language=C++,
  showstringspaces=false,
  basicstyle=\footnotesize\ttfamily,
  keywordstyle=\bfseries\color{blue},
  commentstyle=\itshape\color{gray},
  identifierstyle=\color{black},
  stringstyle=\color{orange},
}

\begin{document}


\thispagestyle{empty}
\materia{Algoritmos y estructuras de dato III}
\submateria{Segundo Cuatrimestre de 2015}
\titulo{Diseño de algoritmos sobre grafos}
\subtitulo{Aplicación de técnicas 2.0}
\integrante{Coy, Camila Paula}{33/14}{camicoy94@gmail.com} % por cada integrante (apellido, nombre) (n° libreta) (e-mail)
\integrante{Fadel, Uriel}{104/14}{urielfadel@gmail.com}
\integrante{Porto, Jorge}{376/11}{cuanto.p.p@gmail.com}
\integrante{Soliz, Carlos}{406/12}{rcarlos.cs@gmail.com}

\maketitle
\newpage

\thispagestyle{empty}
\vfill

\thispagestyle{empty}
\vspace{1.5cm}
\tableofcontents
\newpage

%\normalsize

\newpage
\section{Objetivos generales}
\setcounter{page}{1}

El objetivo del siguiente trabajo sera la práctica de distintos técnicas para elaboración de algoritmos.
Tal trabajo consta de tres situaciones que bien pueden ser aplicadas a la vida real, se buscara resolverlos de forma óptima. \newline
En el primer problema se aplicaran algoritmos de programación dinámica. El segundo y tercer problemas, se modelaran en grafos, para así llegar obtener de manera óptimas resultados, esto algoritmos estarán basados en dfs y krukal levemente modificados.  
%\newpage



%\newpage
\section{Problema 1}
\input{problema1}

\newpage
\section{Problema 2}
\input{problema2}

\newpage
\section{Problema 3}
\input{problema3}

%\input{apendice}
\section{}
\begin{thebibliography}{abbrvnat}
\bibitem{teorica} Teórica de Algoritmos y Estructuras de datos III, Departamento Computación, Facultad de Ciencias Exactas y Naturales, UBA.
\end{thebibliography}


\newpage
\section{Informe de modificaciones}

En esta sección se enumeraran las modificaciones que se le hicieron al informe ejercicio por ejercicio.

Ejercicio 1: \newline

1) Se modifico la subsección de \underline{descripción del problema} dado que estaba mal redactado.

2) Se modifico la subsección de \underline{desarrollo de la idea y pseudocódigo} de la siguiente manera:
	\begin{itemize}
		\item Se agrego pseudocódigo.
		\item Se volvió a explicar el desarrollo de la idea de modo que quede mas clara la resolución del problema y se agregaron referencias a fragmentos del pseudocódigo de tal forma que sea mas amena la lectura.
	\end{itemize}
	
3) Se modifico la subsección de \underline{justificación de la resolución y demostración de correctitud}.	
	
4) Se modifico la subsección de \underline{Análisis de complejidad propuesta} de la siguiente manera:	
	\begin{itemize}
		\item Se modifico la explicación de la complejidad propuesta, de manera tal que quede en forma ordenada.
		\item Se agregaron referencias al pseudocódigo, para que el entendimiento de la complejidad se mas legible.
	\end{itemize}

Ejercicio 2: \newline

1) Se agrego una cita.

\bigskip

Ejercicio 3: \newline

1) Se modifico la subsección de \underline{desarrollo de la idea y pseudocódigo} agregando el pseudocódigo.

2) Se modifico la subsección de \underline{Análisis de complejidad.} explicando para que se utiliza el Union Find

3) Se modifico la subsección de \underline{Experimentación y gráficos.} cambiando los gráficos.

\newpage
\section{Apéndice 1: Secciones relevantes del código}
En esta sección, adjuntamos parte del código correspondiente a la resolución de cada problema
que consideramos más relevante.

\subsection{Código del Problema 1}

\begin{lstlisting}[style=customc]
#include<iostream>
#include<cassert>
#include<vector>

using namespace std;

struct Portal{
    int pisoDesde,pisoHasta;
};

class Ejercicio1{
public:
    int solve(int n, vector<Portal> &portales)
    {
		//Primero deberia leer los portales e ir agregando a la matriz los portales..
		//El problema esta resuelto con programacion dinamica, la forma bottom up, primero empezaremos llenandola con los datos que tenemos.
		//Y luego recorriendola, de forma diagonal, y ya sabiendo que cualquier dato que necesitamos ya lo tenemos precalculado.
		int matriz[n][n];
		
		//La lleno con 0, ya que si tiene un 0 quiere decir que no puede llegar, y luego vamos a leer los portales..
		int i=0,j=0;
		for(i = 0; i < n;i++){
			for(j = 0;j < n; j++){
				matriz[i][j] = 0;
			}
		}
		int pisoD,pisoH,suma;
		Portal p1;
		
		//En este for ingreso los portales..
		for(i =0;i< portales.size();i++){
			p1 = portales[i];
			pisoD = p1.pisoDesde;
			pisoH = p1.pisoHasta;
			matriz[pisoD-1][pisoH-1] = 1;
		}
		//Ahora vamos a empezar a recorrer de forma diagonal
		for(i = 1;i<n;i++){ //Voy a hacer este for n veces, lo de adentro del for es del orden: O(n-i+i) => O(n) => O(n*n)
			int max = 0;
			for(j =0;j<i;j++){ //Voy a hacer este for i veces, y lo de adentro es del orden de O(1) => tarda O(i)
				if(matriz[j][i] > max){
					max = matriz[j][i];
				}
			}
			//Tengo el maximo de mi columna, lo que quiere decir que es lo que tardo en llegar hasta mi piso.
			matriz[i][i] = max;
			for(j = i+1;j<n;j++){ //Este for va a iterar n-i veces y lo de adentro lo hace en O(1) => tarda O(n-i)
				if(max == 0){
					matriz[i][j] = 0;
				}else{
					//Tengo que sumarle lo que tardo en llegar a mi piso, si es que ese piso (m [i][j] es accesible, osea tiene un 1)
					if(matriz[i][j] != 0){
						matriz[i][j] = max +1;
					}
				}
			}
		}

		return matriz[n-1][n-1];
    }
};
\end{lstlisting}


\subsection{Código del Problema 2}

\begin{lstlisting}

		FileInputStream entrada =null;  
		BufferedReader reader =null;
		FileWriter escribidor=null;
		
		try{
			entrada = new FileInputStream(args[0]);
			reader = new BufferedReader(new InputStreamReader(entrada));
			escribidor= new FileWriter("Ej2.out");				
			String line=null;	
			int L;
			int N;	
			String[] LyN;
			String[] portales;
			Nodo[] nodosGrafo;	
			while(true){
				
				line=reader.readLine();
				if (line==null) break;

				LyN=line.split(" ");
				L=Integer.parseInt(LyN[0]);
				N=Integer.parseInt(LyN[1]);
				
				line=reader.readLine();
				portales=line.split(";");
				
				nodosGrafo= new Nodo[(L+1)*(N+1)+portales.length];// almacenamos en este arreglo los nodos correspondiendose el indice con el id del nodo
				
				//creamos los nodos
				for(int i=0;i<(L+1)*(N+1);i++){ //complejidad del ciclo O(N*L)
					Nodo nuevo=new Nodo(i);
					nodosGrafo[i]=nuevo;
				}
				
				//asignamos los sucesores de los nodos
				for(int i=0;i<(L+1)*(N+1);i++){  //complejidad del ciclo O(N*L)
					if(i%(L+1)==0) nodosGrafo[i].addSucesor(nodosGrafo[i+1]);
					else if(i%(L+1)==L) nodosGrafo[i].addSucesor(nodosGrafo[i-1]);
					else{
						nodosGrafo[i].addSucesor(nodosGrafo[i+1]);
						nodosGrafo[i].addSucesor(nodosGrafo[i-1]);
					}
				}
				
				//asignamos los sucesores de los portales
				int pisoDesde;
				int baldosaDesde;
				int pisoHasta;
				int baldosaHasta;
				String[] parametrosPortales;
				for(int i=0;i<portales.length;i++){//complejidad del ciclo O(P)
					int idp=(L+1)*(N+1)+i;
					Nodo nodoPortal=new Nodo(idp);
					nodosGrafo[idp] =nodoPortal;
					parametrosPortales=portales[i].trim().split(" ");
				//	System.out.println(parametrosPortales);
					
					pisoDesde=Integer.parseInt(parametrosPortales[0]);
					baldosaDesde=Integer.parseInt(parametrosPortales[1]);
					pisoHasta=Integer.parseInt(parametrosPortales[2]);
					baldosaHasta=Integer.parseInt(parametrosPortales[3]);

					nodoPortal.addSucesor(nodosGrafo[pisoDesde*(L+1)+baldosaDesde]);
					nodosGrafo[pisoDesde*(L+1)+baldosaDesde].addSucesor(nodoPortal);
					
					nodoPortal.addSucesor(nodosGrafo[pisoHasta*(L+1)+baldosaHasta]);
					nodosGrafo[pisoHasta*(L+1)+baldosaHasta].addSucesor(nodoPortal);
				}
				
				//tenemos una complejidad de O(N*L+P) antes de aplicar bfs
				
				//aplicamos bfs
				
				Queue<Nodo> cola= new LinkedList<Nodo>();
				cola.add(nodosGrafo[0]);
				nodosGrafo[0].marcar();
				bfs:
				while(!(cola.isEmpty())){
					Nodo w=cola.remove();
					for(Nodo z : w.getSucesores()){ //complejidad O(d(w)) (donde d(w) indica la cantidad de sucesores de w)
						if(z.getId()==(N+1)*(L+1)-1){
							System.out.println(w.getDistancia()+1);
							escribidor.write(Integer.toString(w.getDistancia()+1));						
							escribidor.write("\n");
							break bfs;
						}	
						if(!(z.isMarcado())){
							z.marcar();
							cola.add(z);
							z.setDistancia(w.getDistancia()+1);
						}
					}
				}// la complejidad de este ciclo depende de el numero de iteraciones antes de encontrar el nodo buscado, en el peor caso se visitan todos los nodos


\end{lstlisting}

\subsection{Código del Problema 3}

\begin{lstlisting}[style=customc]

class Arista{
	private:
		unsigned int _nod1, _nod2;
		int _peso;
		
	public:
		Arista(unsigned int n1, unsigned int n2, int p) : _nod1(n1), _nod2(n2), _peso(p) {}
		int peso() const { return _peso; }
		unsigned int nodo1() const { return _nod1; }
		unsigned int nodo2() const { return _nod2; }
		
		bool operator<(const Arista &ar) const {
			if(peso() != ar.peso()) return peso() < ar.peso();
			if(nodo1() != ar.nodo1()) return nodo1() < ar.nodo1();
			return nodo2() < ar.nodo2();
		}

};

class UnionFind{
	private:
		vector<unsigned int> _parent, _rank;
		
	public:
		UnionFind(unsigned int n){
			for(unsigned int i = 0; i < n; i++){
				_parent.push_back(i);
				_rank.push_back(0);
			}
		}
		
		unsigned int findSet(unsigned int i){ 
			if(_parent[i] == i){
				return i;
			}else{
				_parent[i] = findSet(_parent[i]);
				return _parent[i];
			}
		}
		
		bool isSameSet(unsigned int i, unsigned int j){
			return findSet(i) == findSet(j);
			
		}
		
		void unionSet(unsigned int i, unsigned int j){
			if( !isSameSet(i,j) ){
				unsigned int jParent = findSet(j);
				unsigned int iParent = findSet(i);
				if(_rank[iParent] > _rank[jParent]){
					_parent[jParent] = iParent;
				}else if(_rank[iParent] < _rank[jParent]){
					_parent[iParent] = jParent;
				}else{
					_parent[jParent] = iParent;
					_rank[iParent]++; 
				}
			}
		}
};

int kruskalModificado(int n, vector<Arista> todas){
	sort(todas.begin(), todas.end());
	reverse(todas.begin(), todas.end());
	UnionFind arbol = UnionFind(n);
	int peso = 0;
	for(unsigned int i = 0; i < todas.size(); i++){
		if( !arbol.isSameSet(todas[i].nodo1(), todas[i].nodo2()) ){
			arbol.unionSet(todas[i].nodo1(), todas[i].nodo2());
		}else{
			peso = peso + todas[i].peso();
		}
	}
	return peso;
}

\end{lstlisting}




%\vspace*{0.5cm}

%\begin{lstlisting}
%int main(){
%  return 0;
%}
%\end{lstlisting}


%\vspace*{0.5cm}

%\newpage
%\subsection{Código del Problema 3}

%\begin{lstlisting}
%int main(){
%  return 0;
%}
%\end{lstlisting}

%\vspace*{0.5cm}

%\begin{lstlisting}
%int main(){
%  return 0;
%}
%\end{lstlisting}




\end{document}
